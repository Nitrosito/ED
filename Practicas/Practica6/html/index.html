<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>My Project: Práctica árboles</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Práctica árboles </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#Objetivo">Objetivo</a><ul><li class="level2"><a href="#wiki">Según Wikipedia ...</a></li>
</ul>
</li>
<li class="level1"><a href="#Fecha">Entrega</a></li>
<li class="level1"><a href="#Documentacion">Arboles Balanceados AVL</a></li>
<li class="level1"><a href="#Insercion">Inserción</a></li>
<li class="level1"><a href="#Borrar">Borrado en AVL</a></li>
<li class="level1"><a href="#tda">TDA AVL</a></li>
</ul>
</div>
<div class="textblock"><dl class="section version"><dt>Version</dt><dd>v0 </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Juan F. Huete</dd></dl>
<h1><a class="anchor" id="Objetivo"></a>
Objetivo</h1>
<p>El objetivo de la práctica es que el alumno practique con el tipo de dato abstracto árbol, en concreto con los árboles binarios utilizando la implementación de bintree que se encuentra en la página de la asignatura. En concreto se pide entregar una implementación del TDA AVL, donde se deben seguir la misma especificación del set de la STL.</p>
<h2><a class="anchor" id="wiki"></a>
Según Wikipedia ...</h2>
<p>El árbol AVL toma su nombre de las iniciales de los apellidos de sus inventores, Georgii Adelson-Velskii y Yevgeniy Landis. Lo dieron a conocer en la publicación de un artículo en 1962, «An algorithm for the organization of information» («Un algoritmo para la organización de la información»).</p>
<div class="fragment"><div class="line">ver mas en https:<span class="comment">//es.wikipedia.org/wiki/Árbol_AVL</span></div>
</div><!-- fragment --> <h1><a class="anchor" id="Fecha"></a>
Entrega</h1>
<p>La fecha de entrega de la práctica es el día 22 de Enero de 2016.</p>
<h1><a class="anchor" id="Documentacion"></a>
Arboles Balanceados AVL</h1>
<p>El tiempo requerido para realizar las operaciones de inserción, búsqueda y borrado en un árbol binario de búsqueda es proporcional a la longitud del camino (número de arcos) que hay desde la raíz hasta la hoja. En el caso en que el árbol esté balanceado el número de arcos es del orden O(log n), sin embargo cuando consideramos la inserción estándar en un árbol binario de búsqueda no hay nada que evite que la estructura resultante pueda quedar completamente desbalanceada. En esta situación, como por ejemplo lo es la tipología resultante cuando se insertan en un ABB un conjunto de elementos ordenados, el árbol no es más que una estructura de lista enlazada, siendo el camino de la raíz a la hoja proporcional al número de nodos, esto es O(n).</p>
<p>Para poder asegurar que dichas operaciones se realicen de forma eficiente (O(log n)) debemos de asegurarnos que el árbol resultante este lo más balanceado posible.</p>
<p>Podemos pensar en distintos criterios para definir el balanceo de un árbol binario, por ejemplo:</p>
<ul>
<li>El subárbol izquierdo y derecho de la raíz tengan el mismo número de nodos o, de forma alternativa, la misma altura. Estas son condiciones muy débiles y podemos encontrar de forma fácil contraejemplos que nos muestren que la estructura del árbol no está correctamente balancedo.</li>
</ul>
<ul>
<li>Una alternativa sería exigir que la anterior propiedad se cumpla para todos los nodos, esto es, los subárboles izquierdo y derecho de CADA nodo tengan el mismo número de nodos o, de forma alternativa, la misma altura. Esta condición si nos garantiza tener la estructura balanceda, sin embargo es demasiado restrictiva pues sólo se puede cumplir para el caso de árbol binario perfecto.</li>
</ul>
<ul>
<li>Por tanto podemos relajar la condición de equilibrio, exigindo lo que se denomina condición AVL: La diferencia entre al altura del hijo izquierda y derecha de cada nodo del árbol es como mucho de 1, esto es:</li>
</ul>
<div class="fragment"><div class="line">Para cada nodo x,  -1 &lt;=  balanceo(x)   &lt;= 1</div>
<div class="line">donde  balanceo(node) = altura(node.left() ) - altura(node.right()).</div>
</div><!-- fragment --><p>Si garantizamos la condición de AVL la estructura resultante tiene una altura del orden O(log n). Esto lo podemos ver si tenemos en cuenta que el número mínimo de nodos en un AVL de altura h, M(h), se determina considerando la siguiente ecuación recurrente:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ M(h) = M(h-1)+M(h-2) +1, \mbox{ con } M(-1) = 0 \mbox{ y } M(0) = 1. \]" src="form_0.png"/>
</p>
<p>La solución a esta ecuación de recurrencia es <img class="formulaInl" alt="$M(h) = 1.62^h$" src="form_1.png"/>.</p>
<p>Esta es una propiedad interesante, mucho más si tenemos en cuenta que tras las operaciones de inserción y borrado que puedan desbalancear un árbol, la condición de AVL puede recuperarse de forma conveniente (mediante operaciones de orden constante, O(1)) realizando rotaciones simples y dobles, sin que por ello se vea afectada la propiedad de ser un árbol binario de búsqueda.</p>
<p>Para conocer cuando realizar una rotación, es necesario conocer la altura del nodo. Una primera posibilidad sería calcular dicho valor cuando sea necesario, sin embargo esto reduciría considerablemente la eficiencia de los algoritmos de inserción y/o borrado. En su lugar, lo que haremos será almacenar en cada nodo, además de la información asociada al tipo de dato para el que se particulariza en TDA, la altura del nodo (de forma alternativa se podría también almancenar el factor de balanceo), esto es</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, ...&gt;</div>
<div class="line"><span class="keyword">class </span>AVL {</div>
<div class="line"><span class="keyword">typedef</span> <span class="keywordtype">int</span> altura;</div>
<div class="line">....</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="comment">// Metodos privados</span></div>
<div class="line">   altura h(<a class="code" href="classbintree.html">bintree</a>&lt;pair&lt;T,altura&gt; &gt;::node &amp; n);</div>
<div class="line">   altura h(<a class="code" href="classbintree.html">bintree</a>&lt;pair&lt;T,altura&gt; &gt;::const_node &amp; n);</div>
<div class="line"> <span class="comment">// Representacion</span></div>
<div class="line">  <a class="code" href="classbintree.html">bintree &lt;pair&lt;T,altura&gt;</a> &gt; el_avl;</div>
<div class="line">};</div>
</div><!-- fragment --><p>Por tanto en todo momento podremos conocer la altura de un nodo utilizando el método h(n), además supondremos que tenemos el método "balancear" que será el encargado de realizar las operaciones necesarias para asegurar que la estructura resultante siga siendo un AVL. Así si tras realizar una inserción o borrado nos encontramos que el factor de balanceo es por ejemplo 2, debemos de determinar qué tipo de rotación debemos hacer, simple o doble, y una vez rebalanceado debemos de actualizar la altura de la estructura resultante.</p>
<p>Pasaremos a describir de forma simple los procesos de inserción y borrado. En cualquier caso se recomienda mirar las transparencias de clase.</p>
<h1><a class="anchor" id="Insercion"></a>
Inserción</h1>
<p>La inserción se realiza como la inserción normal en un árbol binario de búsqueda, ABB, pero se añade un proceso de chequeo de balanceo para cada nodo n en el camino que conecta el nuevo nodo insertado con la raíz comprobando uno de los siguientes 4 casos (sólo puede ocurrir uno de ellos)</p>
<ul>
<li>n.left().left() es demasiado alto ==&gt; rotación simple a la derecha </li>
<li>n.left().right() es demasiado alto ==&gt; rotación doble izquierda - derecha </li>
<li>n.right().right() es demasidado alto ==&gt; rotación simple a la izquierda </li>
<li>n.right().left() es demasiado alto ==&gt; rotación doble derecha - izquierda</li>
</ul>
<p>Determinar cada uno de estos casos nos ayuda a decidir el tipo de rotación (simple o doble). Más aun, en el momento en que se realiza la primera rotación podemos asegurar que la estructura resultante ya está balanceada, esto es para todos los ancestros se cumple la condición de balanceo AVL, ya que el árbol estaba balanceado antes de la inserción del nuevo elemento.</p>
<h1><a class="anchor" id="Borrar"></a>
Borrado en AVL</h1>
<p>Al igual que se realiza el proceso de inserción, el borrado requiere borrar los elementos como un ABB normal. Recordad que el proceso de borrado en ABB siempre afecta a la estructura del árbol para un nodo que tiene cero (hoja) o un único hijo.</p>
<p>Si consideramos que eliminamos un nodo hoja la condición de desbalanceo debe ocurrir necesariamente en algún nodo en el camino que va desde su padre hasta la raíz del árbol, por lo que debemos de asegurar que se cumple la condición de balanceo para cada uno de estos nodos (no olvidemos cambiar la altura de los nodos en el proceso). Debemos de tener en cuenta que en el caso del borrado puede ocurrir que exista más de un nodo que necesite ser rebalanceado ya que al rotar un nodo puede propagar la diferencia de altura a sus ancestros. Esto no es un problema ya que repetiremos el proceso para todos los nodos que nos encontremos en el camino a la raíz.</p>
<h1><a class="anchor" id="tda"></a>
TDA AVL</h1>
<p>Como hemos dicho, el tipo de dato a implementar será el TDA AVL que seguirá una especificiación similar a la que tenemos en el set de la stl. Por tanto, sólo indicaremos los nombres de los métodos que se tienen que implementar, la especificación de cada uno de ellos la podremos rescatar del set, por lo que:</p>
<ul>
<li>No existen elementos repetidos </li>
<li>T representa al tipo de dato sobre el que queremos instanciar el AVL. </li>
<li>comparar debe ser un predicado binario que define un orden estricto sobre los elementos de T, donde <img class="formulaInl" alt="$ comp(x,y) $" src="form_2.png"/> es cierto si x precede a y en el orden definido.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">class</span> comparar=less&lt;T&gt; &gt;</div>
<div class="line"><span class="keyword">class </span>AVL {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"><span class="comment">// entre otros deberemos implementar los siguientes métodos, para los que debemos darle el mismo funcionamiento que viene indicado en la clase set</span></div>
<div class="line"></div>
<div class="line"><span class="comment">//constructores</span></div>
<div class="line">avl ...</div>
<div class="line"><span class="comment">//operador de asignacion</span></div>
<div class="line">opeator=  ...</div>
<div class="line"><span class="comment">//iteradores</span></div>
<div class="line">begin  ...</div>
<div class="line">end ...</div>
<div class="line">rbegin ...</div>
<div class="line">rend ...</div>
<div class="line">cbegin  ...</div>
<div class="line">cend  ...</div>
<div class="line">crbegin  ...</div>
<div class="line">crend  ...</div>
<div class="line"></div>
<div class="line"><span class="comment">//Capacidad</span></div>
<div class="line">empty ...</div>
<div class="line">size ...</div>
<div class="line"></div>
<div class="line"><span class="comment">//Modificadores:</span></div>
<div class="line">insert  ...</div>
<div class="line">erase ...</div>
<div class="line">swap  ...</div>
<div class="line">clear  ...</div>
<div class="line"></div>
<div class="line"><span class="comment">//Operaciones:</span></div>
<div class="line">find  ...</div>
<div class="line">lower_bound  ...</div>
<div class="line">upper_bound  ...</div>
<div class="line"></div>
<div class="line">private:</div>
<div class="line">  <span class="comment">// Metodos privados</span></div>
<div class="line">   altura h(<a class="code" href="classbintree.html">bintree</a>&lt;pair&lt;T,altura&gt; &gt;::node &amp; n);</div>
<div class="line">   altura h(<a class="code" href="classbintree.html">bintree</a>&lt;pair&lt;T,altura&gt; &gt;::const_node &amp; n);</div>
<div class="line">   .... </div>
<div class="line"></div>
<div class="line"> <span class="comment">// Representacion</span></div>
<div class="line">  <a class="code" href="classbintree.html">bintree &lt;pair&lt;T,altura&gt;</a> &gt; el_avl;</div>
<div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> tama;</div>
<div class="line">  comparar cmp;</div>
<div class="line">};</div>
</div><!-- fragment --> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
